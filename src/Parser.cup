import java_cup.runtime.*;
import java.util.ArrayList;

scan with {: return lexer.next_token(); :};

parser code {:

    public boolean syntaxErrors;
    public void syntax_error(Symbol current_token) {
        report_error(
            "Syntax error at line " + (current_token.left+1) + ", column "
    + current_token.right + "\n", null
        );
    }

  private boolean debug = false;
  public boolean  debug()         {return debug;}
  public void     debug(boolean b){debug = b;}

  static class Node {
    public ArrayList<Node> children;
    private static int globalCounter = 0;

    public int counter;
    private Object value;

    public Node(Object value){
      Node.globalCounter += 1;
      this.counter = Node.globalCounter;
      this.value = value;
      this.children = new ArrayList<Node>();
    }

    public void addChild(Node n){ children.add(n); }

    public String toString(){
      String ret = "";
      ret += String.format("%d [label=\"%s\"];\n",
                            counter, value.toString());
      for(Node n: children){
        ret += String.format("%d -> %d;\n", this.counter, n.counter);
        ret += n.toString();
      }
      return ret;
    }
  }

  private Lexer lexer;

  public Parser(Lexer lex) {
    super(lex);
    lexer = lex;
  }

:};

// Do something with ILLEGAL_CHARARCTER or drop it.
terminal INTEGER, IDENTIFIER, EQUAL, SEMICOL, PLUS, MINUS, MULT, DIV, INT, FLOAT, BOOL, TOP, RAT, CHAR, POW, DICT, COMMA, COL, RETURN;
terminal LPAREN, RPAREN;
terminal LPAREN_CURLY, RPAREN_CURLY;
terminal BADCHAR;
terminal INTEGER_LITERAL;
terminal MAIN_FUNC;
terminal METHOD_DECLARATOR;

nonterminal statements, statement, top_level;
nonterminal let_bind, full_exp, simple_exp, operator_binary;
nonterminal method_declaration, method_header, method_body, methods;
nonterminal parameter_list, parameter;
nonterminal primitive_type, floating_point_type, numeric_type, integer_type, type;

precedence left PLUS, MINUS;
precedence left DIV, MULT;
precedence right POW;


methods ::= methods method_declaration | method_declaration;
method_declaration ::= method_header LPAREN_CURLY method_body RPAREN_CURLY SEMICOL
                        | method_header LPAREN_CURLY method_body RETURN IDENTIFIER SEMICOL RPAREN_CURLY COL type SEMICOL
                        | MAIN_FUNC LPAREN_CURLY statements RPAREN_CURLY SEMICOL
                        | MAIN_FUNC LPAREN_CURLY method_body RETURN SEMICOL RPAREN_CURLY SEMICOL
                        | MAIN_FUNC LPAREN_CURLY method_body RETURN IDENTIFIER SEMICOL RPAREN_CURLY SEMICOL;

method_header ::=  METHOD_DECLARATOR IDENTIFIER LPAREN parameter_list RPAREN;
method_body ::= statements | ;


parameter_list ::= parameter_list COMMA parameter | parameter;
parameter ::= IDENTIFIER COL primitive_type | ;


statements ::= statements statement | statement;
statement  ::= full_exp SEMICOL;
full_exp   ::= IDENTIFIER COL type EQUAL simple_exp
                | IDENTIFIER COL type;
simple_exp  ::= simple_exp operator_binary simple_exp
            | LPAREN simple_exp RPAREN
            | INTEGER_LITERAL
            ;

operator_binary ::= PLUS
            | MINUS
            | MULT
            | DIV
            | POW
            ;



type ::= primitive_type;
primitive_type ::= numeric_type | BOOL;
numeric_type ::= integer_type | floating_point_type;
integer_type ::= INT | CHAR;
floating_point_type ::= FLOAT | RAT;






//top_level ::= statements:ss {:
//                if(debug()) System.out.println((Node)ss);
//              :}
//            ;
//
//statements ::= statements:ss statement:s {:
//                  Node n = (Node)ss;
//                  n.addChild((Node)s);
//                  RESULT = n;
//               :}
//             | /* empty */ {:
//                  RESULT = new Node("Statements");
//               :}
//             ;
//
//statement ::= let_bind:s {:
//                RESULT = (Node)s;
//              :}
//            | full_exp:s {:
//                RESULT = (Node)s;
//              :}
//            ;
//
//full_exp ::= simple_exp:e SEMICOL {: RESULT = (Node)e; :};
//
//simple_exp ::= INTEGER:i    {: RESULT = new Node(i); :}
//             | IDENTIFIER:i {: RESULT = new Node(i); :}
//             | simple_exp:e1 operator:o simple_exp:e2 {:
//                  Node n = (Node)o;
//                  n.addChild((Node)e1);
//                  n.addChild((Node)e2);
//                  RESULT = n;
//               :}
//             | LPAREN simple_exp:e RPAREN {:
//                 Node n = new Node("parens");
//                 n.addChild(new Node("("));
//                 n.addChild((Node)e);
//                 n.addChild(new Node(")"));
//                 RESULT = (Node)e;
//               :}
//             ;
//
//integral_type ::= INT {: RESULT = new Node(n); :}
//;
//
//operator ::= PLUS  {: RESULT = new Node("+"); :}
//           | MINUS {: RESULT = new Node("-"); :}
//           | MULT  {: RESULT = new Node("*"); :}
//           | DIV   {: RESULT = new Node("/"); :}
//           | POW   {: RESULT = new Node("^"); :}
//           ;
//
////let_bind ::= LET IDENTIFIER:i EQUAL full_exp:e {:
////               Node n = new Node("INT");
////               n.addChild(new Node(i));
////               n.addChild((Node)e);
////               RESULT = n;
////             :};
//
//top_bind ::= TOP IDENTIFIER:i EQUAL full_exp:e {:
//                 Node n = new Node("TOP");
//                 n.addChild(new Node(i));
//                 n.addChild((Node)e);
//                 RESULT = n;
//
//               :};
