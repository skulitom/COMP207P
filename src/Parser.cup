import java_cup.runtime.*;
import java.util.ArrayList;

scan with {: return lexer.next_token(); :};

parser code {:

    public boolean syntaxErrors;
    public void syntax_error(Symbol current_token) {
        report_error(
            "Syntax error at line " + (current_token.left+1) + ", column "
    + current_token.right + "\n", null
        );
    }

  private boolean debug = false;
  public boolean  debug()         {return debug;}
  public void     debug(boolean b){debug = b;}

  static class Node {
    public ArrayList<Node> children;
    private static int globalCounter = 0;

    public int counter;
    private Object value;

    public Node(Object value){
      Node.globalCounter += 1;
      this.counter = Node.globalCounter;
      this.value = value;
      this.children = new ArrayList<Node>();
    }

    public void addChild(Node n){ children.add(n); }

    public String toString(){
      String ret = "";
      ret += String.format("%d [label=\"%s\"];\n",
                            counter, value.toString());
      for(Node n: children){
        ret += String.format("%d -> %d;\n", this.counter, n.counter);
        ret += n.toString();
      }
      return ret;
    }
  }

  private Lexer lexer;

  public Parser(Lexer lex) {
    super(lex);
    lexer = lex;
  }

:};

// Do something with ILLEGAL_CHARARCTER or drop it.
terminal INTEGER, IDENTIFIER, EQUAL, SEMICOL, PLUS, MINUS, MULT, DIV, INT, FLOAT, BOOL, TOP, DOT, LEN, STRING, NULL,
 RAT, CHAR, POW, DICT, COMMA, COL, RETURN, SEQ, ALIAS, QUOTE, SINGLE_QUOTE, NOT, AND, OR, QUESTION, IMPLY, STRING_LITERAL, PRINT;
terminal LPAREN, RPAREN;
terminal LPAREN_CURLY, RPAREN_CURLY, LPAREN_TRI, RPAREN_TRI, LPAREN_SQ, RPAREN_SQ;
terminal BADCHAR;
terminal INTEGER_LITERAL , CHARACTER, FLOATING, RATIONAL, TRUE, FALSE;
terminal IF, FI, ELSE, BREAK, THEN;
terminal COM_EQUAL, COM_NOT_EQUAL, LESS_THAN, LESS_THAN_OR_EQ;
terminal LOOP, POOL;
terminal MAIN_FUNC;
terminal METHOD_DECLARATOR, TYPE_DECLARATOR;

nonterminal statements, statement, top_level;
nonterminal let_bind, full_exp, simple_exp, operator_binary;
nonterminal method_declaration, method_header, method_body, methods;
nonterminal parameter_list, parameter;
nonterminal primitive_type, floating_point_type, numeric_type, integer_type, type;
nonterminal dictionary_value, dictionary_list, dictionary_structure, comparison, comparison_operators, boolean_operators, custom_type;
nonterminal comparison_list, boolean_twoway_operators, comparable, boolean, comparables_list, string_content, simple_integer_exp, integer_value;
nonterminal list, array, value, string;

precedence left PLUS, MINUS, AND, OR, IMPLY;
precedence left DIV, MULT;
precedence right POW;


methods ::= methods method_declaration | method_declaration;
method_declaration ::= method_header LPAREN_CURLY method_body RPAREN_CURLY SEMICOL
                        | method_header LPAREN_CURLY method_body RETURN IDENTIFIER SEMICOL RPAREN_CURLY COL type SEMICOL
                        | MAIN_FUNC LPAREN_CURLY statements RPAREN_CURLY SEMICOL
                        | MAIN_FUNC LPAREN_CURLY method_body RETURN SEMICOL RPAREN_CURLY SEMICOL
                        | MAIN_FUNC LPAREN_CURLY method_body RETURN IDENTIFIER SEMICOL RPAREN_CURLY SEMICOL;

method_header ::= METHOD_DECLARATOR IDENTIFIER LPAREN parameter_list RPAREN;
method_body ::= statements | ;


statements ::= LOOP statements POOL
                | IF LPAREN comparison_list RPAREN THEN statements FI
                | IF LPAREN comparison_list RPAREN THEN statements  ELSE statements FI
                |statements statement | statement;

statement  ::= full_exp SEMICOL;

full_exp   ::= IDENTIFIER COL type EQUAL simple_exp
                | IDENTIFIER COL SEQ LPAREN_TRI type RPAREN_TRI EQUAL array
                | IDENTIFIER COL DICT LPAREN_TRI INT COMMA type RPAREN_TRI EQUAL dictionary_structure
                | IDENTIFIER COL type
                | IDENTIFIER COL STRING EQUAL string
                | IDENTIFIER EQUAL simple_exp
                | QUESTION simple_exp QUESTION IDENTIFIER LPAREN comparables_list RPAREN
                | BREAK INTEGER_LITERAL
                | PRINT value
                | PRINT IDENTIFIER
                | BREAK;

parameter_list ::= parameter_list COMMA parameter | parameter;
parameter ::= IDENTIFIER COL type | ;

simple_exp  ::= IDENTIFIER LPAREN_SQ simple_integer_exp RPAREN_SQ
            | IDENTIFIER LPAREN_SQ simple_integer_exp COMMA simple_integer_exp RPAREN_SQ
            | simple_exp operator_binary simple_exp
            | LPAREN simple_exp RPAREN
            | value
            | IDENTIFIER
            ;

simple_integer_exp ::= simple_integer_exp operator_binary simple_integer_exp
                               | LPAREN simple_integer_exp RPAREN
                               | integer_value
                               ;

custom_type ::= TYPE_DECLARATOR IDENTIFIER LPAREN_CURLY parameter_list RPAREN_CURLY SEMICOL;

dictionary_structure ::= LPAREN_CURLY dictionary_list RPAREN_CURLY ;

dictionary_list ::= dictionary_list COMMA dictionary_value | dictionary_value | ;

dictionary_value ::= value COL value | LPAREN_CURLY RPAREN_CURLY | LPAREN_CURLY value COL value RPAREN_CURLY;

array ::= LPAREN_SQ list RPAREN_SQ | string;

string ::= STRING_LITERAL;

list ::= list COMMA value | value |;

comparables_list ::= comparables_list COMMA comparable| comparable |;

value ::= INTEGER_LITERAL | CHARACTER | RATIONAL | FLOATING |NULL | boolean ;

boolean ::= TRUE | FALSE;

operator_binary ::= PLUS
            | MINUS
            | MULT
            | DIV
            | POW
            | boolean_twoway_operators
            ;


comparison ::= comparable comparison_operators comparable;
comparison_list ::= comparison_list boolean_twoway_operators comparison
                    |comparison_list boolean_twoway_operators LPAREN comparison RPAREN  | NOT LPAREN comparison RPAREN |LPAREN comparison RPAREN |comparison |;

comparable ::=IDENTIFIER LPAREN_SQ simple_integer_exp COMMA simple_integer_exp RPAREN_SQ| IDENTIFIER LPAREN_SQ simple_integer_exp RPAREN_SQ | value | IDENTIFIER;

integer_value ::= INTEGER_LITERAL | IDENTIFIER DOT LEN | IDENTIFIER;

comparison_operators ::= COM_EQUAL | COM_NOT_EQUAL | LPAREN_TRI | LESS_THAN_OR_EQ | boolean_twoway_operators;

boolean_operators ::= boolean_twoway_operators | NOT;

boolean_twoway_operators ::= AND | OR | IMPLY;

type ::= primitive_type | TOP ;
primitive_type ::= numeric_type | BOOL;
numeric_type ::= integer_type | floating_point_type;
integer_type ::= INT | CHAR ;
floating_point_type ::= FLOAT | RAT;

